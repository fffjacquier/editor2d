package classes.utils 
{
	import flash.utils.getQualifiedClassName;
	/**
	 * This class contains some functions for dealing operations with Numbers.
	 *
	 */
	public final class NumberUtils 
	{
		
		/**
		 * Formats a number to a specific format.
		 * @param number the number to format
		 * @param thousandDelimiter the characters used to delimit thousands, millions, etc; " " if not specified
		 * @param decimalDelimiter the characters used to delimit the fractional portion from the whole number; "." if not specified
		 * @param precision the total number of decimals
		 * @param fillLength  minimal length of the part *before* the decimals delimiter, if the length is less it will be filled up
		 * @param fillChar the character to use to fill with; zero if not specified
		 */
		public static function format(number:Number, decimalDelimiter:String = '.', thousandDelimiter:String = ' ', precision:Number = NaN, fillLength:Number = NaN, fillChar:String = '0'):String
		{
			if(!isNaN(precision))
			{
				number = NumberUtils.roundToPrecision(number, precision);
			}
			
			var str:String = number.toString();
			var p:int = str.indexOf('.');

			var decimals:String = p != -1 ? str.substr(p + 1) : '';
			while (decimals.length < precision) decimals = decimals + '0';
			
			var floored:String = Math.floor(number).toString();
			var formatted:String = '';
			
			if(thousandDelimiter)
			{
				var len:uint = Math.ceil(floored.length / 3) - 1;
				for (var i:int = 0;i < len; ++i)
				{
					formatted = thousandDelimiter + floored.substr(floored.length - (3 * (i + 1)), 3) + formatted;
				}
				formatted = floored.substr(0, floored.length - (3 * i)) + formatted;
			}
			else
			{
				formatted = floored;
			}
			
			if(fillLength && fillChar && fillChar != '')
			{
				while(formatted.length < fillLength) formatted = fillChar + formatted;
			}
			
			if (isNaN(precision) || precision > 0) formatted = formatted + (decimals ? decimalDelimiter + decimals : '');
			
			return formatted;
		}
		
		//
		public static function commonFormat(value:Number):String
		{
			var val:Number = Math.round(value * 100) / 100;
			
			if (val == int(val)) return String(val);
			
			var str:String  = String(val);
			var arr:Array = str.split(".");
			if (arr[1])
			{
				if((arr[1] as String).length == 1) arr[1] += "0";
				str = arr.join(",");
			}
			
			return str;
		}

		/**
		 * Rounds a number to a certain level of precision. Useful for limiting the number of
		 * decimal places on a fractional number.
		 * 
		 * @param number the input number to round.
		 * @param precision	the number of decimal digits to keep
		 * @return the rounded number, or the original input if no rounding is needed
		 */
		public static function roundToPrecision(number:Number, precision:int = 0):Number
		{
			var n:Number = 1;
			while (precision--) 
			{
				n *= 10;
			}
			return Math.round(number * n) / n;
		}

		/**
		 * Tests equality for numbers that may have been generated by faulty floating point math.
		 * This is not an issue exclusive to the Flash Player, but all modern computing in general.
		 * The value is generally offset by an insignificant fraction, and it may be corrected.
		 * 
		 * <p>Alternatively, this function could be used for other purposes than to correct floating
		 * point errors. Certainly, it could determine if two very large numbers are within a certain
		 * range of difference. This might be useful for determining "ballpark" estimates or similar
		 * statistical analysis that may not need complete accuracy.</p>
		 * 
		 * @param number1 the first number to test
		 * @param number2 the second number to test
		 * @param precision	the number of digits in the fractional portion to keep
		 * @return true, if the numbers are close enough to be considered equal, false if not.
		 */
		public static function fuzzyEquals(number1:Number, number2:Number, precision:int = 5):Boolean
		{
			var difference:Number = number1 - number2;
			var range:Number = Math.pow(10, -precision);
			
			//default precision checks the following:
			//0.00001 < difference > -0.00001

			return difference < range && difference > -range;
		}
		
		public static function getClassName(object:*):String
        {
                var qualifiedClassName:String = object is String ? object : getQualifiedClassName(object);
                
                if (qualifiedClassName.indexOf('::') == -1)
                {
                       return qualifiedClassName;
                }
                else
                {
					if (qualifiedClassName.indexOf('<') != -1)
					{
						// Vector exception
						var a:Array = qualifiedClassName.match(/(?<=::)\w+/g);
						var s:String = a.shift();
						var e:String = "";
						while (a.length)
						{
								s += ".<" + a.shift();
								e += ">";
						}
						return s + e;
					}
					else
					{
						return qualifiedClassName.split('::')[1];
					}
                }
        }
		
		public static function log10(val:Number):Number
		{
			return Math.log(val) * 0.434294481904;//Math.LOG10E arrondi
		}
		
		public static function toString():String
		{
			return getClassName(NumberUtils);
		}
	}

}